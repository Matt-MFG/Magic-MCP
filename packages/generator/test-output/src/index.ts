#!/usr/bin/env node

/**
 * github_repos_mcp - MCP Server
 * Subset of GitHub API for testing MCP generation - Repository endpoints
 *
 * Generated by Magic MCP
 * @version 1.0.0
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  Tool,
} from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';

/**
 * Configuration
 */
const CONFIG = {
  name: 'github_repos_mcp',
  version: '1.0.0',
  apiBaseUrl: 'https://api.github.com',
  apiKey: process.env.GITHUB_REPOS_MCP_API_KEY || '',
};

/**
 * Response Types
 */
export type ListForAuthenticatedUserResponse = { id: number; node_id: string; name: string; full_name: string; owner: { login: string; id: number }; private: boolean; html_url: string; description: string | null; fork: boolean; url: string; created_at: string; updated_at: string; pushed_at: string | null; size: number; stargazers_count: number; watchers_count: number; language: string | null; forks_count: number; open_issues_count: number; default_branch: string }[];

export interface CreateForAuthenticatedUserResponse {
  /** Unique identifier of the repository */
  id: number;
  /** GraphQL node ID */
  node_id: string;
  /** The name of the repository */
  name: string;
  /** The full name of the repository including owner */
  full_name: string;
  /** Simple User */
  owner: { login: string; id: number };
  /** Whether the repository is private */
  private: boolean;
  /** URL to the repository on GitHub */
  html_url: string;
  /** The description of the repository */
  description?: string | null;
  /** Whether this repository is a fork */
  fork: boolean;
  /** API URL for the repository */
  url: string;
  /** When the repository was created */
  created_at?: string;
  /** When the repository was last updated */
  updated_at?: string;
  /** When the repository was last pushed to */
  pushed_at?: string | null;
  /** The size of the repository in KB */
  size?: number;
  /** Number of stars */
  stargazers_count?: number;
  /** Number of watchers */
  watchers_count?: number;
  /** The primary programming language */
  language?: string | null;
  /** Number of forks */
  forks_count?: number;
  /** Number of open issues */
  open_issues_count?: number;
  /** The default branch name */
  default_branch?: string;
}

export interface GetResponse {
  /** Unique identifier of the repository */
  id: number;
  /** GraphQL node ID */
  node_id: string;
  /** The name of the repository */
  name: string;
  /** The full name of the repository including owner */
  full_name: string;
  /** Simple User */
  owner: { login: string; id: number };
  /** Whether the repository is private */
  private: boolean;
  /** URL to the repository on GitHub */
  html_url: string;
  /** The description of the repository */
  description?: string | null;
  /** Whether this repository is a fork */
  fork: boolean;
  /** API URL for the repository */
  url: string;
  /** When the repository was created */
  created_at?: string;
  /** When the repository was last updated */
  updated_at?: string;
  /** When the repository was last pushed to */
  pushed_at?: string | null;
  /** The size of the repository in KB */
  size?: number;
  /** Number of stars */
  stargazers_count?: number;
  /** Number of watchers */
  watchers_count?: number;
  /** The primary programming language */
  language?: string | null;
  /** Number of forks */
  forks_count?: number;
  /** Number of open issues */
  open_issues_count?: number;
  /** The default branch name */
  default_branch?: string;
}

export interface UpdateResponse {
  /** Unique identifier of the repository */
  id: number;
  /** GraphQL node ID */
  node_id: string;
  /** The name of the repository */
  name: string;
  /** The full name of the repository including owner */
  full_name: string;
  /** Simple User */
  owner: { login: string; id: number };
  /** Whether the repository is private */
  private: boolean;
  /** URL to the repository on GitHub */
  html_url: string;
  /** The description of the repository */
  description?: string | null;
  /** Whether this repository is a fork */
  fork: boolean;
  /** API URL for the repository */
  url: string;
  /** When the repository was created */
  created_at?: string;
  /** When the repository was last updated */
  updated_at?: string;
  /** When the repository was last pushed to */
  pushed_at?: string | null;
  /** The size of the repository in KB */
  size?: number;
  /** Number of stars */
  stargazers_count?: number;
  /** Number of watchers */
  watchers_count?: number;
  /** The primary programming language */
  language?: string | null;
  /** Number of forks */
  forks_count?: number;
  /** Number of open issues */
  open_issues_count?: number;
  /** The default branch name */
  default_branch?: string;
}


/**
 * Validation Schemas
 */
const ReposListForAuthenticatedUserSchema = z.object({
  visibility: z.enum([&#x27;all&#x27;, &#x27;public&#x27;, &#x27;private&#x27;]).optional().describe('Limit results to repositories with the specified visibility'),
  affiliation: z.string().optional().describe('Comma-separated list of values (owner, collaborator, organization_member)'),
  type: z.enum([&#x27;all&#x27;, &#x27;owner&#x27;, &#x27;public&#x27;, &#x27;private&#x27;, &#x27;member&#x27;]).optional().describe('Limit results to repositories of the specified type'),
  sort: z.enum([&#x27;created&#x27;, &#x27;updated&#x27;, &#x27;pushed&#x27;, &#x27;full_name&#x27;]).optional().describe('The property to sort the results by'),
  direction: z.enum([&#x27;asc&#x27;, &#x27;desc&#x27;]).optional().describe('The order to sort by'),
  per_page: z.number().optional().describe('The number of results per page (max 100)'),
  page: z.number().optional().describe('Page number of the results to fetch'),
});

const ReposCreateForAuthenticatedUserSchema = z.object({
  name: z.string().describe('The name of the repository'),
  description: z.string().optional().describe('A short description of the repository'),
  homepage: z.string().optional().describe('A URL with more information about the repository'),
  private: z.boolean().optional().describe('Whether the repository is private'),
  has_issues: z.boolean().optional().describe('Whether issues are enabled'),
  has_projects: z.boolean().optional().describe('Whether projects are enabled'),
  has_wiki: z.boolean().optional().describe('Whether the wiki is enabled'),
  auto_init: z.boolean().optional().describe('Whether to create an initial commit with empty README'),
  gitignore_template: z.string().optional().describe('Desired language or platform .gitignore template'),
  license_template: z.string().optional().describe('Choose an open source license template'),
});

const ReposGetSchema = z.object({
  owner: z.string().describe('The account owner of the repository'),
  repo: z.string().describe('The name of the repository'),
});

const ReposUpdateSchema = z.object({
  owner: z.string().describe('The account owner of the repository'),
  repo: z.string().describe('The name of the repository'),
  name: z.string().optional().describe('The name of the repository'),
  description: z.string().optional().describe('A short description of the repository'),
  homepage: z.string().optional().describe('A URL with more information about the repository'),
  private: z.boolean().optional().describe('Whether the repository is private'),
  has_issues: z.boolean().optional().describe('Whether issues are enabled'),
  has_projects: z.boolean().optional().describe('Whether projects are enabled'),
  has_wiki: z.boolean().optional().describe('Whether the wiki is enabled'),
  default_branch: z.string().optional().describe('Updates the default branch for this repository'),
  archived: z.boolean().optional().describe('Whether to archive this repository'),
});

const ReposDeleteSchema = z.object({
  owner: z.string().describe('The account owner of the repository'),
  repo: z.string().describe('The name of the repository'),
});


/**
 * API Client
 */
class GithubReposMcpClient {
  private baseUrl: string;
  private apiKey: string;

  constructor() {
    this.baseUrl = CONFIG.apiBaseUrl;
    this.apiKey = CONFIG.apiKey;

    if (!this.apiKey) {
      throw new Error('API key is required. Set GITHUB_REPOS_MCP_API_KEY environment variable.');
    }
  }

  /**
   * Make authenticated API request
   */
  private async request<T>(
    method: string,
    path: string,
    body?: unknown
  ): Promise<T> {
    const url = `${this.baseUrl}${path}`;

    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
1    };

    try {
      const response = await fetch(url, {
        method,
        headers,
        body: body ? JSON.stringify(body) : undefined,
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API request failed (${response.status}): ${errorText}`);
      }

      return await response.json() as T;
    } catch (error) {
      throw new Error(`Request to ${method} ${path} failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * List repositories for the authenticated user
   */
  async reposListForAuthenticatedUser(params: z.infer<typeof ReposListForAuthenticatedUserSchema>): Promise<ListForAuthenticatedUserResponse> {
    const path = '/user/repos';

    // Build query parameters
    const queryParams = new URLSearchParams();
    if (params.visibility !== undefined) {
      queryParams.append('visibility', String(params.visibility));
    }
    if (params.affiliation !== undefined) {
      queryParams.append('affiliation', String(params.affiliation));
    }
    if (params.type !== undefined) {
      queryParams.append('type', String(params.type));
    }
    if (params.sort !== undefined) {
      queryParams.append('sort', String(params.sort));
    }
    if (params.direction !== undefined) {
      queryParams.append('direction', String(params.direction));
    }
    if (params.per_page !== undefined) {
      queryParams.append('per_page', String(params.per_page));
    }
    if (params.page !== undefined) {
      queryParams.append('page', String(params.page));
    }
    const fullPath = `${path}?${queryParams.toString()}`;

    return this.request('GET', fullPath);
  }

  /**
   * Create a repository for the authenticated user
   */
  async reposCreateForAuthenticatedUser(params: z.infer<typeof ReposCreateForAuthenticatedUserSchema>): Promise<CreateForAuthenticatedUserResponse> {
    const path = '/user/repos';

    const fullPath = path;

    // Build request body
    const body = {
      name: params.name,
      description: params.description,
      homepage: params.homepage,
      private: params.private,
      has_issues: params.has_issues,
      has_projects: params.has_projects,
      has_wiki: params.has_wiki,
      auto_init: params.auto_init,
      gitignore_template: params.gitignore_template,
      license_template: params.license_template,
    };
    return this.request('POST', fullPath, body);
  }

  /**
   * Get a repository
   */
  async reposGet(params: z.infer<typeof ReposGetSchema>): Promise<GetResponse> {
    // Build path with parameters
    let path = '/repos/{owner}/{repo}';
    path = path.replace('owner', encodeURIComponent(String(params.owner)));
    path = path.replace('repo', encodeURIComponent(String(params.repo)));

    const fullPath = path;

    return this.request('GET', fullPath);
  }

  /**
   * Update a repository
   */
  async reposUpdate(params: z.infer<typeof ReposUpdateSchema>): Promise<UpdateResponse> {
    // Build path with parameters
    let path = '/repos/{owner}/{repo}';
    path = path.replace('owner', encodeURIComponent(String(params.owner)));
    path = path.replace('repo', encodeURIComponent(String(params.repo)));

    const fullPath = path;

    // Build request body
    const body = {
      name: params.name,
      description: params.description,
      homepage: params.homepage,
      private: params.private,
      has_issues: params.has_issues,
      has_projects: params.has_projects,
      has_wiki: params.has_wiki,
      default_branch: params.default_branch,
      archived: params.archived,
    };
    return this.request('PATCH', fullPath, body);
  }

  /**
   * Delete a repository
   */
  async reposDelete(params: z.infer<typeof ReposDeleteSchema>): Promise<DeleteResponse> {
    // Build path with parameters
    let path = '/repos/{owner}/{repo}';
    path = path.replace('owner', encodeURIComponent(String(params.owner)));
    path = path.replace('repo', encodeURIComponent(String(params.repo)));

    const fullPath = path;

    return this.request('DELETE', fullPath);
  }

}

/**
 * MCP Server Implementation
 */
class GithubReposMcpServer {
  private server: Server;
  private client: GithubReposMcpClient;

  constructor() {
    this.client = new GithubReposMcpClient();

    this.server = new Server(
      {
        name: CONFIG.name,
        version: CONFIG.version,
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
  }

  private setupHandlers(): void {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: 'repos_list_for_authenticated_user',
            description: 'List repositories for the authenticated user',
            inputSchema: {
              type: 'object',
              properties: {
                visibility: {
                  type: 'string',
                  description: 'Limit results to repositories with the specified visibility',
                  enum: ['all', 'public', 'private'],
                },
                affiliation: {
                  type: 'string',
                  description: 'Comma-separated list of values (owner, collaborator, organization_member)',
                },
                type: {
                  type: 'string',
                  description: 'Limit results to repositories of the specified type',
                  enum: ['all', 'owner', 'public', 'private', 'member'],
                },
                sort: {
                  type: 'string',
                  description: 'The property to sort the results by',
                  enum: ['created', 'updated', 'pushed', 'full_name'],
                },
                direction: {
                  type: 'string',
                  description: 'The order to sort by',
                  enum: ['asc', 'desc'],
                },
                per_page: {
                  type: 'number',
                  description: 'The number of results per page (max 100)',
                },
                page: {
                  type: 'number',
                  description: 'Page number of the results to fetch',
                },
              },
              required: [],
            },
          },
          {
            name: 'repos_create_for_authenticated_user',
            description: 'Create a repository for the authenticated user',
            inputSchema: {
              type: 'object',
              properties: {
                name: {
                  type: 'string',
                  description: 'The name of the repository',
                },
                description: {
                  type: 'string',
                  description: 'A short description of the repository',
                },
                homepage: {
                  type: 'string',
                  description: 'A URL with more information about the repository',
                },
                private: {
                  type: 'boolean',
                  description: 'Whether the repository is private',
                },
                has_issues: {
                  type: 'boolean',
                  description: 'Whether issues are enabled',
                },
                has_projects: {
                  type: 'boolean',
                  description: 'Whether projects are enabled',
                },
                has_wiki: {
                  type: 'boolean',
                  description: 'Whether the wiki is enabled',
                },
                auto_init: {
                  type: 'boolean',
                  description: 'Whether to create an initial commit with empty README',
                },
                gitignore_template: {
                  type: 'string',
                  description: 'Desired language or platform .gitignore template',
                },
                license_template: {
                  type: 'string',
                  description: 'Choose an open source license template',
                },
              },
              required: ['name', ],
            },
          },
          {
            name: 'repos_get',
            description: 'Get a repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: {
                  type: 'string',
                  description: 'The account owner of the repository',
                },
                repo: {
                  type: 'string',
                  description: 'The name of the repository',
                },
              },
              required: ['owner', 'repo'],
            },
          },
          {
            name: 'repos_update',
            description: 'Update a repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: {
                  type: 'string',
                  description: 'The account owner of the repository',
                },
                repo: {
                  type: 'string',
                  description: 'The name of the repository',
                },
                name: {
                  type: 'string',
                  description: 'The name of the repository',
                },
                description: {
                  type: 'string',
                  description: 'A short description of the repository',
                },
                homepage: {
                  type: 'string',
                  description: 'A URL with more information about the repository',
                },
                private: {
                  type: 'boolean',
                  description: 'Whether the repository is private',
                },
                has_issues: {
                  type: 'boolean',
                  description: 'Whether issues are enabled',
                },
                has_projects: {
                  type: 'boolean',
                  description: 'Whether projects are enabled',
                },
                has_wiki: {
                  type: 'boolean',
                  description: 'Whether the wiki is enabled',
                },
                default_branch: {
                  type: 'string',
                  description: 'Updates the default branch for this repository',
                },
                archived: {
                  type: 'boolean',
                  description: 'Whether to archive this repository',
                },
              },
              required: ['owner', 'repo', ],
            },
          },
          {
            name: 'repos_delete',
            description: 'Delete a repository',
            inputSchema: {
              type: 'object',
              properties: {
                owner: {
                  type: 'string',
                  description: 'The account owner of the repository',
                },
                repo: {
                  type: 'string',
                  description: 'The name of the repository',
                },
              },
              required: ['owner', 'repo'],
            },
          },
        ],
      };
    });

    // Handle tool calls
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        switch (name) {
          case 'repos_list_for_authenticated_user': {
            const validated = ReposListForAuthenticatedUserSchema.parse(args);
            const result = await this.client.reposListForAuthenticatedUser(validated);
            return {
              content: [
                {
                  type: 'text',
                  text: JSON.stringify(result, null, 2),
                },
              ],
            };
          }
          case 'repos_create_for_authenticated_user': {
            const validated = ReposCreateForAuthenticatedUserSchema.parse(args);
            const result = await this.client.reposCreateForAuthenticatedUser(validated);
            return {
              content: [
                {
                  type: 'text',
                  text: JSON.stringify(result, null, 2),
                },
              ],
            };
          }
          case 'repos_get': {
            const validated = ReposGetSchema.parse(args);
            const result = await this.client.reposGet(validated);
            return {
              content: [
                {
                  type: 'text',
                  text: JSON.stringify(result, null, 2),
                },
              ],
            };
          }
          case 'repos_update': {
            const validated = ReposUpdateSchema.parse(args);
            const result = await this.client.reposUpdate(validated);
            return {
              content: [
                {
                  type: 'text',
                  text: JSON.stringify(result, null, 2),
                },
              ],
            };
          }
          case 'repos_delete': {
            const validated = ReposDeleteSchema.parse(args);
            const result = await this.client.reposDelete(validated);
            return {
              content: [
                {
                  type: 'text',
                  text: JSON.stringify(result, null, 2),
                },
              ],
            };
          }

          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return {
          content: [
            {
              type: 'text',
              text: `Error: ${errorMessage}`,
            },
          ],
          isError: true,
        };
      }
    });
  }

  async run(): Promise<void> {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);

    console.error(`github_repos_mcp MCP Server running on stdio`);
  }
}

/**
 * Main entry point
 */
async function main() {
  const server = new GithubReposMcpServer();
  await server.run();
}

main().catch((error) => {
  console.error('Server error:', error);
  process.exit(1);
});
