/**
 * {{name}} - MCP Server Tests
 * {{description}}
 *
 * Generated by Magic MCP
 * @version {{version}}
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { z } from 'zod';

// Mock fetch globally
global.fetch = vi.fn();

describe('{{pascalCase name}} MCP Server', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('Configuration', () => {
    it('should have valid server configuration', () => {
      expect('{{name}}').toBe('{{name}}');
      expect('{{version}}').toMatch(/^\d+\.\d+\.\d+$/);
      expect('{{apiBaseUrl}}').toMatch(/^https?:\/\//);
    });
  });

  {{#each tools}}
  describe('{{name}}', () => {
    it('should validate input schema correctly', () => {
      const validInput = {
        {{#each parameters}}
        {{#if required}}
        {{name}}: {{#if (eq jsonSchemaType 'string')}}'test-value'{{/if}}{{#if (eq jsonSchemaType 'number')}}123{{/if}}{{#if (eq jsonSchemaType 'boolean')}}true{{/if}}{{#if (eq jsonSchemaType 'array')}}[]{{/if}}{{#if (eq jsonSchemaType 'object')}}{}{{/if}},
        {{/if}}
        {{/each}}
      };

      const {{pascalCase name}}Schema = z.object({
        {{#each parameters}}
        {{name}}: z.{{{zodType}}}{{#if required}}{{else}}.optional(){{/if}},
        {{/each}}
      });

      expect(() => {{pascalCase name}}Schema.parse(validInput)).not.toThrow();
    });

    {{#if hasPathParams}}
    it('should replace path parameters correctly', () => {
      const params = {
        {{#each pathParams}}
        {{name}}: {{#if (eq jsonSchemaType 'string')}}'test-{{name}}'{{/if}}{{#if (eq jsonSchemaType 'number')}}123{{/if}},
        {{/each}}
      };

      let path = '{{endpoint.path}}';
      {{#each pathParams}}
      path = path.replace('{'+ '{{name}}' + '}', encodeURIComponent(String(params.{{name}})));
      {{/each}}

      {{#each pathParams}}
      expect(path).toContain(encodeURIComponent(String(params.{{name}})));
      expect(path).not.toContain('{'+ '{{name}}' + '}');
      {{/each}}
    });
    {{/if}}

    {{#if hasQueryParams}}
    it('should build query parameters correctly', () => {
      const params = {
        {{#each queryParams}}
        {{name}}: {{#if (eq jsonSchemaType 'string')}}'test-value'{{/if}}{{#if (eq jsonSchemaType 'number')}}42{{/if}}{{#if (eq jsonSchemaType 'boolean')}}true{{/if}},
        {{/each}}
      };

      const queryParams = new URLSearchParams();
      {{#each queryParams}}
      if (params.{{name}} !== undefined) {
        queryParams.append('{{name}}', String(params.{{name}}));
      }
      {{/each}}

      const queryString = queryParams.toString();
      {{#each queryParams}}
      expect(queryString).toContain('{{name}}=');
      {{/each}}
    });
    {{/if}}

    {{#if hasBodyParams}}
    it('should construct request body correctly', () => {
      const params = {
        {{#each bodyParams}}
        {{name}}: {{#if (eq jsonSchemaType 'string')}}'test-value'{{/if}}{{#if (eq jsonSchemaType 'number')}}123{{/if}}{{#if (eq jsonSchemaType 'boolean')}}true{{/if}}{{#if (eq jsonSchemaType 'array')}}['item1', 'item2']{{/if}}{{#if (eq jsonSchemaType 'object')}}{ key: 'value' }{{/if}},
        {{/each}}
      };

      const body = {
        {{#each bodyParams}}
        {{name}}: params.{{name}},
        {{/each}}
      };

      {{#each bodyParams}}
      expect(body.{{name}}).toBeDefined();
      {{/each}}
    });
    {{/if}}

    it('should make API request with correct method and headers', async () => {
      const mockResponse = {{#if responseTypeName}}{
        {{#if responseSchema}}
        {{! Generate mock response based on schema }}
        success: true,
        {{/if}}
      }{{else}}{ success: true }{{/if}};

      (global.fetch as any).mockResolvedValueOnce({
        ok: true,
        json: async () => mockResponse,
      });

      // This test validates the structure but doesn't execute the actual client
      // since we can't easily import the generated class without circular dependencies
      expect(global.fetch).toBeDefined();
    });

    it('should handle API errors gracefully', async () => {
      (global.fetch as any).mockResolvedValueOnce({
        ok: false,
        status: 400,
        text: async () => 'Bad Request',
      });

      // Error handling test structure
      expect(global.fetch).toBeDefined();
    });
  });

  {{/each}}

  describe('Integration', () => {
    it('should list all available tools', () => {
      const expectedTools = [
        {{#each tools}}
        '{{name}}',
        {{/each}}
      ];

      expect(expectedTools.length).toBe({{tools.length}});
      {{#each tools}}
      expect(expectedTools).toContain('{{name}}');
      {{/each}}
    });

    it('should have consistent tool naming (snake_case)', () => {
      const toolNames = [
        {{#each tools}}
        '{{name}}',
        {{/each}}
      ];

      toolNames.forEach(name => {
        expect(name).toMatch(/^[a-z][a-z0-9_]*$/);
      });
    });

    {{#if hasAuth}}
    it('should require authentication', () => {
      expect('{{authEnvVar}}').toBeDefined();
      {{#if (eq authType 'bearer')}}
      expect('Bearer token').toBeDefined();
      {{/if}}
      {{#if (eq authType 'apiKey')}}
      expect('{{authHeaderName}}').toBeDefined();
      {{/if}}
    });
    {{/if}}
  });

  describe('Type Safety', () => {
    it('should have properly typed responses', () => {
      {{#each tools}}
      {{#if responseTypeName}}
      // {{name}} returns {{responseTypeName}}
      type {{pascalCase name}}ResponseType = {{responseTypeName}};
      const {{camelCase name}}Response: {{pascalCase name}}ResponseType = {} as {{pascalCase name}}ResponseType;
      expect({{camelCase name}}Response).toBeDefined();
      {{/if}}
      {{/each}}
    });
  });
});
