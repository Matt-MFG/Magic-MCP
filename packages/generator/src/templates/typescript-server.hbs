#!/usr/bin/env node

/**
 * {{name}} - MCP Server
 * {{description}}
 *
 * Generated by Magic MCP
 * @version {{version}}
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  Tool,
} from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';

/**
 * Configuration
 */
const CONFIG = {
  name: '{{name}}',
  version: '{{version}}',
  apiBaseUrl: '{{apiBaseUrl}}',
  {{#if hasAuth}}
  apiKey: process.env.{{authEnvVar}} || '',
  {{/if}}
};

/**
 * Validation Schemas
 */
{{#each tools}}
const {{pascalCase name}}Schema = z.object({
  {{#each parameters}}
  {{name}}: z.{{zodType}}(){{#if required}}{{else}}.optional(){{/if}}{{#if description}}.describe('{{description}}'){{/if}},
  {{/each}}
});

{{/each}}

/**
 * API Client
 */
class {{pascalCase name}}Client {
  private baseUrl: string;
  {{#if hasAuth}}
  private apiKey: string;
  {{/if}}

  constructor() {
    this.baseUrl = CONFIG.apiBaseUrl;
    {{#if hasAuth}}
    this.apiKey = CONFIG.apiKey;

    if (!this.apiKey) {
      throw new Error('API key is required. Set {{authEnvVar}} environment variable.');
    }
    {{/if}}
  }

  /**
   * Make authenticated API request
   */
  private async request<T>(
    method: string,
    path: string,
    body?: unknown
  ): Promise<T> {
    const url = `${this.baseUrl}${path}`;

    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      {{#if hasAuth}}
      {{#eq authType 'bearer'}}
      'Authorization': `Bearer ${this.apiKey}`,
      {{/eq}}
      {{#eq authType 'apiKey'}}
      '{{authHeaderName}}': this.apiKey,
      {{/eq}}
      {{/if}}
    };

    try {
      const response = await fetch(url, {
        method,
        headers,
        body: body ? JSON.stringify(body) : undefined,
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API request failed (${response.status}): ${errorText}`);
      }

      return await response.json() as T;
    } catch (error) {
      throw new Error(`Request to ${method} ${path} failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  {{#each tools}}
  /**
   * {{description}}
   */
  async {{camelCase name}}(params: z.infer<typeof {{pascalCase name}}Schema>): Promise<unknown> {
    {{#if hasPathParams}}
    // Build path with parameters
    let path = '{{endpoint.path}}';
    {{#each pathParams}}
    path = path.replace('{{{name}}}', encodeURIComponent(String(params.{{name}})));
    {{/each}}
    {{else}}
    const path = '{{endpoint.path}}';
    {{/if}}

    {{#if hasQueryParams}}
    // Build query parameters
    const queryParams = new URLSearchParams();
    {{#each queryParams}}
    if (params.{{name}} !== undefined) {
      queryParams.append('{{name}}', String(params.{{name}}));
    }
    {{/each}}
    const fullPath = `${path}?${queryParams.toString()}`;
    {{else}}
    const fullPath = path;
    {{/if}}

    {{#if hasBodyParams}}
    // Build request body
    const body = {
      {{#each bodyParams}}
      {{name}}: params.{{name}},
      {{/each}}
    };
    return this.request('{{endpoint.method}}', fullPath, body);
    {{else}}
    return this.request('{{endpoint.method}}', fullPath);
    {{/if}}
  }

  {{/each}}
}

/**
 * MCP Server Implementation
 */
class {{pascalCase name}}Server {
  private server: Server;
  private client: {{pascalCase name}}Client;

  constructor() {
    this.client = new {{pascalCase name}}Client();

    this.server = new Server(
      {
        name: CONFIG.name,
        version: CONFIG.version,
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
  }

  private setupHandlers(): void {
    // List available tools
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {{#each tools}}
          {
            name: '{{name}}',
            description: '{{description}}',
            inputSchema: {
              type: 'object',
              properties: {
                {{#each parameters}}
                {{name}}: {
                  type: '{{jsonSchemaType}}',
                  description: '{{description}}',
                  {{#if enum}}
                  enum: [{{#each enum}}'{{this}}'{{#unless @last}}, {{/unless}}{{/each}}],
                  {{/if}}
                },
                {{/each}}
              },
              required: [{{#each parameters}}{{#if required}}'{{name}}'{{#unless @last}}, {{/unless}}{{/if}}{{/each}}],
            },
          },
          {{/each}}
        ],
      };
    });

    // Handle tool calls
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        switch (name) {
          {{#each tools}}
          case '{{name}}': {
            const validated = {{pascalCase name}}Schema.parse(args);
            const result = await this.client.{{camelCase name}}(validated);
            return {
              content: [
                {
                  type: 'text',
                  text: JSON.stringify(result, null, 2),
                },
              ],
            };
          }
          {{/each}}

          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return {
          content: [
            {
              type: 'text',
              text: `Error: ${errorMessage}`,
            },
          ],
          isError: true,
        };
      }
    });
  }

  async run(): Promise<void> {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);

    console.error(`{{name}} MCP Server running on stdio`);
  }
}

/**
 * Main entry point
 */
async function main() {
  const server = new {{pascalCase name}}Server();
  await server.run();
}

main().catch((error) => {
  console.error('Server error:', error);
  process.exit(1);
});
